# 입문

요약하다 보니 겹치는 내용이 있는 부분은 전 장으로 옮김

<hr>

## 1장 내용 요약

처음은 기계어 0과 1로만 계산을 했다.           
그러나 0과 1만 써서 무언가를 하는 짓은 미친 짓이다.

어느날 어셈블리어가 나온 후 모두가 환호 했다.       
어셈블리어를 쓰면 일상용어를 써서 할 수  있기 때문이다.     
이제 0과 1이 아닌 단어를 사용하여 만들 수 있다.     

`책에는 없지만 이 사이에 OS가 있는듯 `

그후 C언어가 등장했다. `어셈블리어와 C언어 사이 언어도 많지만 건너 뜀`      
어셈블리어 개발자가 환호했다        

`이유`
CPU마다 기계어가 다름 `소스코드가 다름`     
어셈블리어는 일상용어를 기계어로 번역함 `기계어도 많으니 이것도 많음`       
C언어는 소스코드 종류는 하나고 <b>OS별 컴파일러</b>만 존재하면 됨.      

C++ 등장!       
객체 지향 개념을 도입한 언어가 등장함       

Java 등장!      
자바에서는 <b>OS별 컴파일러</b>가 필요가 사라진다. `돈 절약`

Java 소스파일을 짠후        
<b>JDK</b>(자바 번역기)에서 class로 변환하여        
<b>JRE</b>(자바 실행환경 )에서 실행된다     
<b>JVM</b>(자바 가상 컴퓨터) 은 각 플랫폼에서 잘 실행되기 해주는 것     

우리가 흔히 Java를 깔고 cmd 창에서 환경변수 설정하는 이유는             
JDK : javac.exe `자바 소스 컴파일러`                
JRE : java.exe `자바 프로그램 실행`     
## 2장 내용 요약    

#### Java 메모리 사용 방식

코드 실행영역 50%       
데이터 저장영역 50%     

데이터 저장영역은 3분할해서 (스태탁, 스택, 힙) 영역으로 나뉜다.

- 스태틱 영역 
    - 패키지
    - 클래스 
- 스택 영역
    - 메서드 스택 프레임 `() 때 생기고 끝나면 메모리에서 사라짐`
    - 조건문 스택 프레임 `메서드랑 동일함`
    - 변수
- 힙 영역
    - 객체 `new class 객체`

#### 멀티 스레드 / 멀티 프로세스 

<b>멀티 스레드</b>는 스택영역이 스레드 갯수 만큼 들어난다       
<b>멀티 프로세스</b>는 다수의 데이터영역을 갖는 구조이다. (cpu core 갯수)       
멀티 프로세스는 각 프로세스마다 각자의 메모리가 있어 서로 접근 할 수 없다.      
하지만 멀티 스레드는 하나의 데이터영역 안에어 스택 영역끼리는 접근이 불가능 하고 
스태틱 영역과 힙 영역은 접근 가능한다.

## 3장 내용 요약 

개념을 알져주는 내용이 많아 패스

#### 객체 지향의 4대 특성


"캡상추다"

- 캡슐화 : 정보 은닉 
    - public : 모두 접근 가능
    - protected : 상속 / 같은 패키지 내의 클래스에서 접근 가능
    - default : 같은 패키지 내의 클래스에서 접근 가능
    - private : 본인만 접근 가능
- 상속 : 재사용
    - 최상위 클래스 `Object`
    - 상위 클래스
    - 하위 클래스
    - 서브 클래스
- 추상화 : 모델링
- 다형성 : 사용 편의
    - 오버 라이딩
    - 오버 로딩


"메모리"

- static : 클래스 [멤버 속성],정적 변수,정적 속성 = 스태틱 영역
- 인스턴스 변수 : 객체 [멤버 속성], 객체 변수 = 힙 영역
- local변수 : 지역변수 = 스택 영역(프레임 내부)

## 4장 내용 요약

#### abstract
- 추상 메서드, 메서드, 멤버필드, 생성자 
추상메서드는 내용을 정의할 수 없다.
- 추상 메서드 사용법
    - 추상 클래스 상속 
    - 추상 메서드 오버 라이딩

상속은 <b>extends</b>로 상속 받는다.
<b>다중 상속</b>이 불가능하다.

#### 생성자 `인스턴스`

그냥 클래스를 new 로 생성하면 생성자다.

#### staitc 

생성자를 최초로 만들 때 단 한 번 실행된다.

#### final  `상수`

- class 에 final 을 쓸 시 상속을 할 수 없다.
- 변수에 final 을 쓸 시 한 번 값을 넣으면 변경할 수 없다.
- 메서드가 final 이면 오버라이딩이 금지된다.

#### instanceof 연산자

???변수가 ???생성자가 맞는지 물어보는 것
예시 : 객체_참조_변수 instanceof 클래스명

값은 <b>true</b> or <b>false</b> 다.

#### Package 
패키지는 똑같은 이름을 써도 충돌하지 않게 하는 것이다.

#### interface 
- abstract 랑 비슷함 
- 멤버 필드가 모두 final 이다.
- 다중 상속 가능

상속은 <b>implements</b>로 상속받는다.
변수에 final을 안 붙여도 상수가 된다.

#### this
- this는 클래스를 가르킨다.

#### super 
Java는 class는 상속이 가능하다. 
this를 쓰면 class를 가르키지만 상속된 클래스를 가르키진 않는다.
상속된 클래스를 가르키는 메서드가 super다

## 5장 내용 요약

#### Solid 
- SRP : 단일 책임 원칙
어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- OCP : 개방 폐쇄 원칙
자신의 확장에는 열려잇고, 주변의 변화에 대해서는 닫혀 있어야 한다.
- LSP : 리스코프 치환 원칙
서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
- ISP : 인터페이스 분리 원칙
클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
- DIP : 의존 역전 원칙
자신보다 변하기 쉬운 것에 의존하지 마라

## 6장 내용 요약

#### 어댑터 패턴